import atexit
import importlib.util
import logging
import os
from typing import Dict, Optional, Set

from opentelemetry import trace
from opentelemetry.context import get_value, attach, set_value
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import (
    OTLPSpanExporter as GRPCExporter,
)
from opentelemetry.exporter.otlp.proto.http.trace_exporter import (
    OTLPSpanExporter as HTTPExporter,
)
from opentelemetry.instrumentation.logging import LoggingInstrumentor
from opentelemetry.instrumentation.system_metrics import SystemMetricsInstrumentor
from opentelemetry.propagate import set_global_textmap
from opentelemetry.propagators.textmap import TextMapPropagator
from opentelemetry.sdk.resources import Resource
from opentelemetry.sdk.trace import TracerProvider, SpanProcessor
from opentelemetry.sdk.trace.export import (
    SpanExporter,
    SimpleSpanProcessor,
    BatchSpanProcessor,
)
from opentelemetry.trace import get_tracer_provider, ProxyTracerProvider
from opentelemetry.trace.span import Span

from apmplus_server.sdk import is_logs_enabled
from apmplus_server.sdk.instruments import Instruments
from apmplus_server.sdk.semconv import SpanAttributes
from apmplus_server.sdk.utils.context import (
    get_reqid,
    get_account_id,
)

TRACER_NAME = "apmplus.tracer"


class TracerWrapper(object):
    resource_attributes: dict = {}
    enable_content_tracing: bool = True
    endpoint: str = None
    headers: Dict[str, str] = {}

    def __new__(
            cls,
            disable_batch=False,
            processor: SpanProcessor = None,
            propagator: TextMapPropagator = None,
            exporter: SpanExporter = None,
            instruments: Optional[Set[Instruments]] = None,
            system_metrics: str = "true",
    ) -> "TracerWrapper":
        if not hasattr(cls, "instance"):
            obj = cls.instance = super(TracerWrapper, cls).__new__(cls)
            if not TracerWrapper.endpoint:
                return obj

            resource = Resource.create(TracerWrapper.resource_attributes) if TracerWrapper.resource_attributes else Resource.create()
            obj.__resource = resource
            obj.__tracer_provider: TracerProvider = init_tracer_provider(
                resource=obj.__resource
            )
            if processor:
                logging.info("apmplus_llm.TracerWrapper:init", {"processor": "custom"})
                obj.__spans_processor: SpanProcessor = processor
            else:
                obj.__spans_exporter: SpanExporter = (
                    exporter
                    if exporter
                    else init_spans_exporter(
                        TracerWrapper.endpoint, TracerWrapper.headers
                    )
                )
                if disable_batch:
                    obj.__spans_processor: SpanProcessor = SimpleSpanProcessor(
                        obj.__spans_exporter
                    )
                else:
                    obj.__spans_processor: SpanProcessor = BatchSpanProcessor(
                        obj.__spans_exporter
                    )
                logging.info("apmplus_llm.TracerWrapper:init",
                      {
                          "exporter": {type(obj.__spans_exporter).__name__},
                          "processor": {type(obj.__spans_processor).__name__},
                      },
                      )

            obj.__spans_processor.on_start = obj._span_processor_on_start
            obj.__tracer_provider.add_span_processor(obj.__spans_processor)

            if propagator:
                set_global_textmap(propagator)


            if is_logs_enabled():
                LoggingInstrumentor().instrument()
                logging.info("apmplus_llm.logging instrument")

            system_metrics = os.getenv("APMPLUS_SYSTEM_METRICS") or system_metrics
            if system_metrics.lower() == "true":
                SystemMetricsInstrumentor().instrument()
                logging.info("apmplus_llm.systemMetrics instrument")

            instrument_set = False
            if instruments is None:
                init_instrumentations()
                instrument_set = True
            else:
                for instrument in instruments:
                    if instrument == Instruments.ARK_RUN_TIME:
                        if not init_ark_instrumentor():
                            logging.warning("volcenginesdkarkruntime library does not exist.")
                        else:
                            instrument_set = True
                    else:
                        logging.warning( " %s instrument does not exist.",instrument)

            if not instrument_set:
                logging.warning( "No valid instruments set. Remove 'instrument' argument to use all instruments, or set a valid instrument.")

            # Force flushes for debug environments (e.g. local development)
            atexit.register(obj.exit_handler)

        return cls.instance

    def exit_handler(self):
        self.flush()

    def _span_processor_on_start(self, span, parent_context):
        workflow_name = get_value("workflow_name")
        if workflow_name is not None:
            span.set_attribute(SpanAttributes.APMPLUS_WORKFLOW_NAME, workflow_name)

        association_properties = get_value("association_properties")
        if association_properties is not None:
            for key, value in association_properties.items():
                span.set_attribute(
                    f"{SpanAttributes.APMPLUS_ASSOCIATION_PROPERTIES}.{key}", value
                )

            if not self.enable_content_tracing:
                attach(set_value("override_enable_content_tracing", False))

        if is_llm_span(span):
            prompt_key = get_value("prompt_key")
            if prompt_key is not None:
                span.set_attribute(SpanAttributes.LLM_PROMPT_KEY, prompt_key)

            prompt_version = get_value("prompt_version")
            if prompt_version is not None:
                span.set_attribute("apmplus_llm.prompt.version", prompt_version)

            prompt_version_name = get_value("prompt_version_name")
            if prompt_version_name is not None:
                span.set_attribute("apmplus_llm.prompt.version_name", prompt_version_name)

            prompt_version_hash = get_value("prompt_version_hash")
            if prompt_version_hash is not None:
                span.set_attribute("apmplus_llm.prompt.version_hash", prompt_version_hash)

            prompt_template_variables = get_value("prompt_template_variables")
            if prompt_version_hash is not None:
                for key, value in prompt_template_variables.items():
                    span.set_attribute(
                        f"apmplus_llm.prompt.template_variables.{key}", value
                    )

    @staticmethod
    def set_static_params(
            resource_attributes: dict,
            enable_content_tracing: bool,
            endpoint: str,
            headers: Dict[str, str],
    ) -> None:
        TracerWrapper.resource_attributes = resource_attributes
        TracerWrapper.enable_content_tracing = enable_content_tracing
        TracerWrapper.endpoint = endpoint
        TracerWrapper.headers = headers

    @classmethod
    def verify_initialized(cls) -> bool:
        if hasattr(cls, "instance"):
            return True

        if (os.getenv("APMPLUS_LLM_SUPPRESS_WARNINGS") or "false").lower() == "true":
            return False
        logging.warning("APMPlus Tracer not initialized, make sure you call Tracer.init()")
        return False

    def flush(self):
        self.__spans_processor.force_flush()

    def get_tracer(self):
        return self.__tracer_provider.get_tracer(TRACER_NAME)


def set_correlation_id(correlation_id: str) -> None:
    attach(set_value("correlation_id", correlation_id))


def set_association_properties(properties: dict) -> None:
    attach(set_value("association_properties", properties))


def set_workflow_name(workflow_name: str) -> None:
    attach(set_value("workflow_name", workflow_name))


def set_prompt_tracing_context(
        key: str,
        version: int,
        version_name: str,
        version_hash: str,
        template_variables: dict,
) -> None:
    attach(set_value("prompt_key", key))
    attach(set_value("prompt_version", version))
    attach(set_value("prompt_version_name", version_name))
    attach(set_value("prompt_version_hash", version_hash))
    attach(set_value("prompt_template_variables", template_variables))


def is_llm_span(span) -> bool:
    return span.attributes.get(SpanAttributes.LLM_REQUEST_TYPE) is not None


def init_spans_exporter(api_endpoint: str, headers: Dict[str, str]) -> SpanExporter:
    if "80" in api_endpoint.lower():
        # return HTTPExporter(endpoint=f"{api_endpoint}/v1/traces", headers=headers)
        return HTTPExporter(endpoint=f"{api_endpoint}", headers=headers)
    else:
        return GRPCExporter(endpoint=f"{api_endpoint}", headers=headers)


def init_tracer_provider(resource: Resource) -> TracerProvider:
    provider: TracerProvider = None
    default_provider: TracerProvider = get_tracer_provider()

    if isinstance(default_provider, ProxyTracerProvider):
        provider = TracerProvider(resource=resource)
        trace.set_tracer_provider(provider)
    elif not hasattr(default_provider, "add_span_processor"):
        logging.error(
            "Cannot add span processor to the default provider since it doesn't support it"
        )
        return
    else:
        provider = default_provider

    return provider


def init_instrumentations():
    init_ark_instrumentor()


def init_ark_instrumentor():
    if importlib.util.find_spec("volcenginesdkarkruntime") is not None:
        from apmplus_server.instrumentation.ark_runtime import ArkRuntimeInstrumentor
        instrumentor = ArkRuntimeInstrumentor()

        if not instrumentor.is_instrumented_by_opentelemetry:
            instrumentor.instrument()
            logging.info("apmplus_llm:volcenginesdkarkruntime instrument ")
        return True
    return False

def set_common_trace_attributes(
    span: Span,
) -> None:

    span.set_attribute("request_id", get_reqid())
    span.set_attribute("account_id", get_account_id())
    return
