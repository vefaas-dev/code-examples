import inspect
import logging
import os
from functools import wraps
from typing import Any, AsyncGenerator, Iterable, TypeVar, Optional

from opentelemetry import context as context_api
from opentelemetry import trace

from apmplus_server.sdk.semconv import SpanAttributes, APMPlusLlmSpanKindValues
from apmplus_server.sdk.tracing import TracerWrapper
from apmplus_server.sdk.tracing.context_manager import get_tracer
from apmplus_server.sdk.tracing.tracing import set_common_trace_attributes
from apmplus_server.sdk.utils import aenumerate
from apmplus_server.sdk.utils.types import dump_json_str

T = TypeVar("T", covariant=True)


def task(name: Optional[str] = None,
         apmplus_span_kind: Optional[APMPlusLlmSpanKindValues] = APMPlusLlmSpanKindValues.TASK,
         trace_all: bool = True):
    def task_wrapper(fn):  # type: ignore
        async def async_exec(*args: Any, **kwargs: Any) -> Any:
            if not TracerWrapper.verify_initialized():
                return await fn(*args, **kwargs)
            task_name = name or fn.__qualname__
            span_name = f"{task_name}.{apmplus_span_kind.value}"
            with get_tracer() as tracer:
                with tracer.start_as_current_span(name=span_name) as span:
                    span.set_attribute(
                        SpanAttributes.APMPLUS_SPAN_KIND, apmplus_span_kind.value
                    )
                    span.set_attribute(SpanAttributes.APMPLUS_ENTITY_NAME, task_name)
                    span.set_attribute(SpanAttributes.APMPLUS_FUNCTION_TYPE, "async_execution")
                    set_common_trace_attributes(span)
                    try:
                        if _should_send_io():
                            span.set_attribute(
                                SpanAttributes.APMPLUS_ENTITY_INPUT,
                                dump_json_str({"args": args, "kwargs": kwargs}),
                            )
                    except TypeError:
                        logging.warning(f"some args might not be serializable,args:{args}, kwargs:{kwargs}")
                        pass  # Some args might not be serializable

                    try:
                        result = await fn(
                            *args, **kwargs
                        )
                        span.set_status(trace.Status(
                            status_code=trace.StatusCode.OK,
                        ))

                    except Exception as e:
                        handle_exception(span, e)
                        raise e

                    try:
                        if _should_send_io():
                            span.set_attribute(
                                SpanAttributes.APMPLUS_ENTITY_OUTPUT, dump_json_str(result),
                            )
                    except TypeError:
                        logging.warning(f"some args might not be serializable,{result}")
                        pass  # Some args might not be serializable
                    return result

        def sync_exec(*args: Any, **kwargs: Any) -> Any:
            if not TracerWrapper.verify_initialized():
                return fn(*args, **kwargs)
            task_name = name or fn.__qualname__
            span_name = f"{task_name}.{apmplus_span_kind.value}"
            with get_tracer() as tracer:
                with tracer.start_as_current_span(span_name) as span:
                    span.set_attribute(
                        SpanAttributes.APMPLUS_SPAN_KIND, apmplus_span_kind.value
                    )
                    span.set_attribute(SpanAttributes.APMPLUS_ENTITY_NAME, task_name)
                    span.set_attribute(SpanAttributes.APMPLUS_FUNCTION_TYPE, "sync_execution")
                    set_common_trace_attributes(span)
                    try:
                        if _should_send_io():
                            span.set_attribute(
                                SpanAttributes.APMPLUS_ENTITY_INPUT,
                                dump_json_str({"args": args, "kwargs": kwargs}),
                            )
                    except TypeError:
                        logging.warning(f"some args might not be serializable,args:{args}, kwargs:{kwargs}")
                        pass  # Some args might not be serializable

                    try:
                        result = fn(*args, **kwargs)
                        status = trace.Status(
                            status_code=trace.StatusCode.OK,
                        )
                        span.set_status(status)

                    except Exception as e:
                        handle_exception(span, e)
                        raise e

                    try:
                        if _should_send_io():
                            span.set_attribute(
                                SpanAttributes.APMPLUS_ENTITY_OUTPUT, dump_json_str(result),
                            )
                    except TypeError:
                        logging.warning(f"some args might not be serializable,{result}")
                        pass  # Some args might not be serializable
                    return result

        @wraps(fn)
        async def async_iter_task(*args: Any, **kwargs: Any) -> AsyncGenerator[T, None]:
            if not TracerWrapper.verify_initialized():
                async for i, resp in aenumerate(fn(*args, **kwargs)):  # type: ignore
                    yield resp
                return
            task_name = name or fn.__qualname__
            span_name = f"{task_name}.{apmplus_span_kind.value}"

            # trace
            with get_tracer() as tracer:
                # with tracer.start_as_current_span(name=span_name) as span:
                span = tracer.start_span(span_name)
                context_api.attach(context_api.set_value(trace._SPAN_KEY, span))
                # token = context_api.attach(context_api.get_current())

                span.set_attribute(
                    SpanAttributes.APMPLUS_SPAN_KIND, apmplus_span_kind.value
                )
                span.set_attribute(SpanAttributes.APMPLUS_ENTITY_NAME, task_name)
                span.set_attribute(SpanAttributes.APMPLUS_FUNCTION_TYPE, "async_generator")
                set_common_trace_attributes(span)
                try:
                    if _should_send_io():
                        span.set_attribute(
                            SpanAttributes.APMPLUS_ENTITY_INPUT,
                            dump_json_str({"args": args, "kwargs": kwargs}),
                        )
                except TypeError:
                    logging.warning(f"some args might not be serializable,args:{args}, kwargs:{kwargs}")
                    pass  # Some args might not be serializable

                try:
                    async for i, resp in aenumerate(
                            fn(*args, **kwargs)):  # type: ignore
                        yield resp
                except Exception as e:
                    handle_exception(span, e)
                    raise e
                finally:
                    # detach context
                    # context_api.detach(token)
                    span.end()


        @wraps(fn)
        def iter_task(*args: Any, **kwargs: Any) -> Iterable[T]:
            if not TracerWrapper.verify_initialized():
                for i, resp in enumerate(fn(*args, **kwargs)):  # type: ignore
                    yield resp
                return
            task_name = name or fn.__qualname__
            span_name = f"{task_name}.{apmplus_span_kind.value}"
            with get_tracer() as tracer:
                with tracer.start_as_current_span(name=span_name) as span:
                    span.set_attribute(
                        SpanAttributes.APMPLUS_SPAN_KIND, apmplus_span_kind.value
                    )
                    span.set_attribute(SpanAttributes.APMPLUS_ENTITY_NAME, task_name)
                    span.set_attribute(SpanAttributes.APMPLUS_FUNCTION_TYPE, "sync_generator")
                    set_common_trace_attributes(span)

                    try:
                        if _should_send_io():
                            span.set_attribute(
                                SpanAttributes.APMPLUS_ENTITY_INPUT,
                                dump_json_str({"args": args, "kwargs": kwargs}),
                            )
                    except TypeError:
                        logging.warning(f"some args might not be serializable,args:{args}, kwargs:{kwargs}")
                        pass  # Some args might not be serializable

                    try:
                        for i, resp in enumerate(fn(*args, **kwargs)):
                            yield resp
                    except Exception as e:
                        handle_exception(span, e)
                        raise e
                    # finally:
                    #     # detach context
                    #     context_api.detach(span._context.token)

        if inspect.isasyncgenfunction(fn):
            return async_iter_task
        elif inspect.isgeneratorfunction(fn):
            return iter_task
        elif inspect.iscoroutinefunction(fn):
            return async_exec
        else:
            return sync_exec

    return task_wrapper


def handle_exception(span: trace.Span, exception: Exception) -> None:
    status = trace.Status(
        status_code=trace.StatusCode.ERROR,
        # Follow the format in OTEL SDK for description, see:
        # https://github.com/open-telemetry/opentelemetry-python/blob/2b9dcfc5d853d1c10176937a6bcaade54cda1a31/opentelemetry-api/src/opentelemetry/trace/__init__.py#L588  # noqa E501
        description=f"{type(exception).__name__}: {exception}",
    )
    span.set_status(status)
    span.record_exception(exception)


def _should_send_io():
    return (
            os.getenv("APMPLUS_TRACE_CONTENT") or "true"
    ).lower() == "true" or context_api.get_value("override_enable_content_tracing")
